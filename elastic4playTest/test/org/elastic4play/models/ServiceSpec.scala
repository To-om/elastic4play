//package org.elastic4play.models
//
//import java.util.Date
//
//import akka.stream.Materializer
//import akka.stream.scaladsl.{ Sink, Source }
////import com.sksamuel.elastic4s.mappings.TextFieldDefinition
//import scala.concurrent.ExecutionContext.Implicits.{ global ⇒ ec }
//import scala.concurrent.duration._
//import scala.concurrent.{ Await, Future }
//import scala.util.Success
//
//import play.api.libs.json._
//import play.api.test.{ PlaySpecification, WithApplication }
//
//import com.sksamuel.elastic4s.searches.SearchDefinition
//import org.mockito.ArgumentCaptor
//import org.specs2.mock.Mockito
//
//import org.elastic4play.database._
//import org.elastic4play.services._
//import org.elastic4play.utils.Hash
//
//class ServiceSpec extends PlaySpecification with Mockito {
//
//  object PersonStatus extends Enumeration with HiveEnumeration {
//    type Type = Value
//    val Ok, Deleted = Value
//  }
//
//  case class Person(
//    name: String,
//    age: Long,
//    hairColor: Option[String],
//    @WithoutOutput internalAttribute: String,
//    autoGeneratedAttribute: String,
//    avatar: Option[Attachment],
//    status: PersonStatus.Type)
//
//  object Person extends ModelHolder[Person] {
//    val model = Model[Person]
//  }
//
//  case class PersonSrv(
//      dbGet: DBGet = mock[DBGet],
//      dbFind: DBFind = mock[DBFind],
//      dbCreate: DBCreate = mock[DBCreate],
//      dbModify: DBModify = mock[DBModify],
//      dbRemove: DBRemove = mock[DBRemove],
//      dbSequence: DBSequence = mock[DBSequence],
//      dbIndex: DBIndex = mock[DBIndex],
//      eventSrv: EventSrv = mock[EventSrv],
//      attachmentSrv: AttachmentSrv = mock[AttachmentSrv]) {
//    val entitySrv = new EntitySrvFactory(
//      dbGet,
//      dbFind,
//      dbCreate,
//      dbModify,
//      dbRemove,
//      dbSequence,
//      dbIndex,
//      eventSrv,
//      attachmentSrv, ec).withoutParent(Person.model)
//
//    def get(personId: String) = entitySrv.get(personId)
//
//    def nextSequence(sequenceName: String): Future[Int] = entitySrv.nextSequence(sequenceName)
//
//    def create(person: Person)(implicit authContext: AuthContext): Future[Person with Entity] = {
//      entitySrv.create(person)
//    }
//
//    def delete(id: String)(implicit authContext: AuthContext): Future[Person with Entity] = {
//      for {
//        person ← get(id)
//        updatedPerson ← delete(person)
//      } yield updatedPerson
//    }
//
//    def delete(person: Person with Entity)(implicit authContext: AuthContext): Future[Person with Entity] = {
//      entitySrv.update(person, Map(FPath("status") → UpdateOps.SetAttribute(PersonStatus.Deleted)), true) // FIXME PersonStatus.Deleted should be a jsvalue
//    }
//
//    def realDelete(id: String)(implicit authContext: AuthContext): Future[Unit] = entitySrv.delete(id)
//
//    def update(id: String, updates: Map[FPath, UpdateOps.Type])(implicit authContext: AuthContext): Future[Person with Entity] = {
//      for {
//        person ← get(id)
//        updatedPerson ← update(person, updates)
//      } yield updatedPerson
//    }
//
//    def update(person: Person with Entity, updates: Map[FPath, UpdateOps.Type])(implicit authContext: AuthContext): Future[Person with Entity] = entitySrv.update(person, updates, false)
//
//    def getSize: Future[Long] = entitySrv.getSize
//
//    def find(queryDef: QueryDef, range: Option[String], sortBy: Seq[String]): Source[Person with Entity, Future[Long]] = {
//      entitySrv.find(queryDef, range, sortBy)
//    }
//  }
//
//  def inAuthContext[A](
//    _userId: String = "userId",
//    _userName: String = "userName",
//    _requestId: String = "requestId",
//    _roles: Seq[Role.Type] = Seq(Role.read, Role.write, Role.admin))(body: AuthContext ⇒ A): A = {
//    val authContext = new AuthContext {
//      val userId = _userId
//      val userName = _userName
//      val requestId = _requestId
//      val roles = _roles
//    }
//    body(authContext)
//  }
//
//  implicit class AwaitableFuture[A](f: Future[A]) {
//    def await: A = Await.result(f, 1.minute)
//  }
//
//  "a model service" should {
//
//    "get an entity" in {
//      val dbGet = mock[DBGet]
//      dbGet("person", "franckId") returns Future.successful(Json.obj(
//        "name" → "Franck",
//        "age" → 14,
//        "hairColor" → JsNull,
//        "autoGeneratedAttribute" → "generatedCode",
//        "internalAttribute" → "iii",
//        "avatar" → Json.obj(
//          "name" → "mypic.png",
//          "hashes" → Json.arr(""),
//          "size" → 58349,
//          "contentType" → "image/png",
//          "id" → "kok"),
//        "status" → "Ok",
//        "_createdAt" → 1506697890000L,
//        "_createdBy" → "me",
//        "_id" → "franckId",
//        "_routing" → "franckRouting",
//        "_type" → "person",
//        "_parent" → JsNull))
//
//      inAuthContext() { implicit authContext ⇒
//        val person = PersonSrv(dbGet = dbGet).get("franckId").await
//        person must_=== new Person(
//          name                   = "Franck",
//          age                    = 14,
//          hairColor              = None,
//          internalAttribute      = "iii",
//          autoGeneratedAttribute = "generatedCode",
//          avatar                 = Some(FAttachment("mypic.png", Seq(Hash("")), 58349, "image/png", "kok")),
//          status                 = PersonStatus.Ok) with Entity {
//          val _id = "franckId"
//          val _routing = "franckRouting"
//          val _model = Person.model
//          val _parent = None
//          val _createdAt = new Date(1506697890000L)
//          val _createdBy = "me"
//          val _updatedAt = None
//          val _updatedBy = None
//        }
//      }
//    }
//
//    /*
//    e class Person(
//    name: String,
//    age: Long,
//    hairColor: Option[String],
//    @WithoutOutput internalAttribute: String,
//    autoGeneratedAttribute: String,
//    avatar: Option[Attachment],
//    status: PersonStatus.Type)
//     */
//    "generate a new sequence" in {
//      val dbSequence = mock[DBSequence]
//      dbSequence.next("sequenceName") returns Future.successful(42)
//      PersonSrv(dbSequence = dbSequence).nextSequence("sequenceName").await must_=== 42
//    }
//
//    //    "create an entity" in {
//    //      val avatar = FileInputValue("mypic.png", Paths.get("mypic.png"), "image/png")
//    //      val avatarAttachment = AttachmentInputValue("mypic.png", Seq(Hash("")), 58349, "image/png", "kok")
//    //      val personRecord = Record(HNil).transformInto[Person.model.CreationRecord](
//    //        _.add('name, "Franck"),
//    //        _.add('age, 14L),
//    //        _.add('hairColor, None),
//    //        _.add('avatar, Some(avatar)),
//    //        _.add('status, Some(PersonStatus.Ok)))
//    //      val personJson = Json.obj(
//    //        "name" → "Franck",
//    //        "age" → 14,
//    //        "hairColor" → JsNull,
//    //        "internalAttribute" → "internalValue",
//    //        "autoGeneratedAttribute" → "newValue",
//    //        "status" → "Ok",
//    //        "avatar" → Json.obj(
//    //          "name" → "mypic.png",
//    //          "hashes" → Json.arr(""),
//    //          "size" → 58349,
//    //          "contentType" → "image/png",
//    //          "id" → "kok"))
//    //
//    //      val attachmentSrv = mock[AttachmentSrv]
//    //      val dbCreate = mock[DBCreate].verbose
//    //      val eventSrv = mock[EventSrv]
//    //
//    //      attachmentSrv.save(avatar) returns Future.successful(avatarAttachment)
//    //
//    //      dbCreate("person", None, None, None, personJson) returns Future.successful(personJson +
//    //        ("_id" → JsString("FranckId")) +
//    //        ("_routing" → JsString("someRoutingInformation")) +
//    //        ("_parent" → JsNull) +
//    //        ("_type" → JsString("person")))
//    //      inAuthContext() { implicit authContext ⇒
//    //        val person = PersonSrv(dbCreate = dbCreate, attachmentSrv = attachmentSrv, eventSrv = eventSrv).create(personRecord).await
//    //        val auditOperationCaptor = ArgumentCaptor.forClass(classOf[AuditOperation])
//    //        there was one(eventSrv).publish(auditOperationCaptor.capture)
//    //        val auditOperation = auditOperationCaptor.getValue
//    //
//    //        person.name must_=== "Franck"
//    //        person.age must_=== 14
//    //        person.hairColor must beNone
//    //        person.autoGeneratedAttribute must_=== "newValue"
//    //        person.avatar must beSome(AttachmentInputValue("mypic.png", Seq(Hash("")), 58349, "image/png", "kok"))
//    //        person._id must_=== "FranckId"
//    //        person._routing must_=== "someRoutingInformation"
//    //        person._model must_=== Person.model
//    //        person._parent must beNone
//    //
//    //        auditOperation.action must_=== AuditableAction.Creation
//    //        auditOperation.entity must_=== person
//    //        auditOperation.details must_=== personJson
//    //        auditOperation.authContext must_=== authContext
//    //      }
//    //    }
//
//    "delete entity (change status)" in {
//      val dbGet = mock[DBGet]
//      val dbModify = mock[DBModify]
//      val eventSrv = mock[EventSrv]
//
//      val personJson = Json.obj(
//        "name" → "Franck",
//        "age" → 14,
//        "hairColor" → JsNull,
//        "autoGeneratedAttribute" → "generatedCode",
//        "internalAttribute" → "iii",
//        "avatar" → Json.obj(
//          "name" → "mypic.png",
//          "hashes" → Json.arr(""),
//          "size" → 58349,
//          "contentType" → "image/png",
//          "id" → "kok"),
//        "status" → "Ok",
//        "_createdAt" → 1506697890000L,
//        "_createdBy" → "me",
//        "_id" → "123",
//        "_routing" → "someRoutingInformation",
//        "_type" → "person",
//        "_parent" → JsNull)
//
//      dbGet("person", "123") returns Future.successful(personJson)
//      dbModify("person", "123", "someRoutingInformation", None,
//        Map(
//          FPath("status") → UpdateOps.SetDBAttribute(Some(JsString("Deleted"))))) returns Future.successful(personJson + ("status" → JsString("Deleted")))
//      inAuthContext() { implicit authContext ⇒
//        val person = PersonSrv(dbGet = dbGet, dbModify = dbModify, eventSrv = eventSrv).delete("123").await
//        val auditOperationCaptor = ArgumentCaptor.forClass(classOf[AuditOperation])
//        there was one(eventSrv).publish(auditOperationCaptor.capture)
//        val auditOperation = auditOperationCaptor.getValue
//
//        person.status must_=== PersonStatus.Deleted
//
//        auditOperation.action must_=== AuditableAction.Delete
//        auditOperation.entity must_=== person
//        auditOperation.details must_=== JsObject(Nil)
//        auditOperation.authContext must_=== authContext
//      }
//    }
//
//    "delete entity" in {
//      val dbGet = mock[DBGet]
//      val dbRemove = mock[DBRemove]
//      val eventSrv = mock[EventSrv]
//
//      val personJson = Json.obj(
//        "name" → "Franck",
//        "age" → 14,
//        "hairColor" → JsNull,
//        "autoGeneratedAttribute" → "generatedCode",
//        "internalAttribute" → "iii",
//        "avatar" → Json.obj(
//          "name" → "mypic.png",
//          "hashes" → Json.arr(""),
//          "size" → 58349,
//          "contentType" → "image/png",
//          "id" → "kok"),
//        "status" → "Ok",
//        "_createdAt" → 1506697890000L,
//        "_createdBy" → "me",
//        "_id" → "123",
//        "_routing" → "franckRouting",
//        "_type" → "person",
//        "_parent" → JsNull)
//
//      dbGet("person", "123") returns Future.successful(personJson)
//      dbRemove("person", "123", "franckRouting") returns Future.successful(true)
//
//      inAuthContext() { implicit authContext ⇒
//        val ret = PersonSrv(dbGet = dbGet, dbRemove = dbRemove, eventSrv = eventSrv).realDelete("123")
//        ret.await
//        val auditOperationCaptor = ArgumentCaptor.forClass(classOf[AuditOperation])
//        there was one(eventSrv).publish(auditOperationCaptor.capture)
//        val auditOperation = auditOperationCaptor.getValue
//
//        ret.value.get must_=== Success(())
//
//        auditOperation.action must_=== AuditableAction.Delete
//        auditOperation.details must_=== JsObject(Nil)
//        auditOperation.authContext must_=== authContext
//      }
//    }
//
//    "update entity" in {
//      val dbGet = mock[DBGet]
//      val dbModify = mock[DBModify]
//      val eventSrv = mock[EventSrv]
//
//      val personJson = Json.obj(
//        "name" → "Franck",
//        "age" → 14,
//        "hairColor" → JsNull,
//        "autoGeneratedAttribute" → "generatedCode",
//        "internalAttribute" → "iii",
//        "avatar" → Json.obj(
//          "name" → "mypic.png",
//          "hashes" → Json.arr(""),
//          "size" → 58349,
//          "contentType" → "image/png",
//          "id" → "kok"),
//        "status" → "Ok",
//        "_createdAt" → 1506697890000L,
//        "_createdBy" → "me",
//        "_id" → "123",
//        "_routing" → "franckRouting",
//        "_type" → "person",
//        "_parent" → JsNull)
//      dbGet("person", "123") returns Future.successful(personJson)
//      dbModify("person", "123", "franckRouting", None,
//        Map(
//          FPath("hairColor") → UpdateOps.UnsetAttribute,
//          FPath("age") → UpdateOps.SetDBAttribute(Some(JsNumber(15))))) returns Future.successful(
//          personJson - "hairColor" + ("age" → JsNumber(15)))
//
//      inAuthContext() { implicit authContext ⇒
//        val person = PersonSrv(dbGet = dbGet, dbModify = dbModify, eventSrv = eventSrv).update("123", Map[FPath, UpdateOps.Type](
//          FPath("age") → UpdateOps.SetAttribute(15L),
//          FPath("hairColor") → UpdateOps.UnsetAttribute)).await
//
//        person.age must_=== 15
//        person.hairColor must_=== None
//
//        val auditOperationCaptor = ArgumentCaptor.forClass(classOf[AuditOperation])
//        there was one(eventSrv).publish(auditOperationCaptor.capture)
//        val auditOperation = auditOperationCaptor.getValue
//
//        auditOperation.action must_=== AuditableAction.Update
//        auditOperation.details must_=== Json.obj("age" → 15, "hairColor" → JsArray())
//        auditOperation.authContext must_=== authContext
//
//      }
//    }
//
//    "get number of entities" in {
//      val dbIndex = mock[DBIndex]
//      dbIndex.getSize("person") returns Future.successful(42L)
//      PersonSrv(dbIndex = dbIndex).getSize.await must_=== 42L
//    }
//
//    "find entities" in new WithApplication() {
//      import org.elastic4play.services.QueryDSL.SearchField
//      implicit val mat = app.injector.instanceOf(classOf[Materializer])
//
//      val personJson = Json.obj(
//        "name" → "Franck",
//        "age" → 14,
//        "hairColor" → JsNull,
//        "autoGeneratedAttribute" → "generatedCode",
//        "internalAttribute" → "iii",
//        "avatar" → Json.obj(
//          "name" → "mypic.png",
//          "hashes" → Json.arr(""),
//          "size" → 58349,
//          "contentType" → "image/png",
//          "id" → "kok"),
//        "status" → "Ok",
//        "_createdAt" → 1506697890000L,
//        "_createdBy" → "me",
//        "_id" → "franckId",
//        "_routing" → "franckRouting",
//        "_type" → "person",
//        "_parent" → JsNull)
//      val dbFind = mock[DBFind]
//
//      dbFind(any[Option[String]], any[Seq[String]])(any[String ⇒ SearchDefinition]) returns Source.single(personJson).mapMaterializedValue(_ ⇒ Future.successful(1L))
//      val ret = PersonSrv(dbFind = dbFind).find("hairColor" ~= "blond", Some("10-25"), Seq("name", "-age"))
//
//      val queryCaptor = ArgumentCaptor.forClass(classOf[String ⇒ SearchDefinition])
//      val rangeCaptor = ArgumentCaptor.forClass(classOf[Option[String]])
//      val sortCaptor = ArgumentCaptor.forClass(classOf[Seq[String]])
//      there was one(dbFind).apply(rangeCaptor.capture, sortCaptor.capture)(queryCaptor.capture())
//      rangeCaptor.getValue must_== Some("10-25")
//      sortCaptor.getValue must_== Seq("name", "-age")
//
//      val (personList, total) = ret.toMat(Sink.seq) {
//        case (futureTotal, futurePerson) ⇒
//          for {
//            ft ← futureTotal
//            fp ← futurePerson
//          } yield (fp, ft)
//      }
//        .run
//        .await
//      personList.size must_=== 1
//      personList.head.name must_=== "Franck"
//      total must_=== 1L
//    }
//  }
//}
